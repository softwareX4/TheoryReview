1、String s = "";和new String（）；的区别
String类是不可变的，没有提供对其私有成员的操作方法，s只是String对象的一个引用（4字节），里面存的java封装了的地址，重新给s赋值只是改变了它指向的位置，而不是改变了原String的值，String提供的replace等函数也是返回了一个新的对象地址。非要修改原对象值，可以使用反射，获取私有对象value，value是一个引用，final只是使它不能指向其他对象，但可以用它修改原来的值
String s = "";会先从常量池中查找是否有该对象，有的话直接引用它，==判断相等，new String("");会根据常量池的String对象在堆中重新new一块内存构造String对象，将新的String赋给引用，所以==不同了
Java中所有对象都由一个引用指向，不能直接操作对象本身。

2、JAVA有哪些锁，可重入锁的意义
可重入锁就是可递归调用的锁，外层使用锁后内层仍然可以使用锁（ReentrantLock通过维护一个private volatile int state计录重入次数），不可重入锁若重入会导致死锁
CAS就是并发线程获取值后，如要更新，先判断我认为这个地方应该是我刚刚取得值，如果是这个值那我就更新他，否则你告诉我它现在是什么值就好了，是乐观锁的一种。java中的原子类就是这样，但只能保证一个共享变量的原子操作。（CAS原理通过调用JNI代码实现，compareAndSwapInt借助C调用CPU底层指令实现，存在ABA问题）
资源竞争严重时用synchronized避免过多浪费CPU，竞争较少使用CAS
java给对象分配内存时可能不安全，同一块内存分配给多个对象，采用CAS\TLAB-本地线程分配缓存区(每个线程预分配一小块内存，线程间内存分配互不干扰，扩充时才CAS)

3、redis底层结构为什么不用红黑树选择跳跃表，采用INCRE自增原子性操作实现类似投票的场景为什么可以防范并发（CAS乐观锁）
跳跃表便于做范围操作，实现简单，插入删除影响小，（内存消耗跳跃表稍大）
且在并发环境下，红黑树因为插入删除颠覆节点较多需要发生大面积争抢锁的现象

4、mysql引擎选择和索引建立，主键和联合主键，常用优化方案
优化主要在安全和性能方面，优化选择SQL及索引>数据库表结构>系统配置>硬件
分析top SQL 用explain调试查看语句执行时间
硬件：根据CPU密集型OLTP还是IO密集型OLAP选择不同核数和主频的cpu，IO密集型需要跟多内存，cpu密集型一般为核心数量二到四倍，根据数据种类选择存储设备，配置RAID级别，选择支持更高流量的网络设备。
系统：尽量不要使用SWAP，IO调度
应用优化：关闭无用服务
数据库优化：执行计划，SQL改写，索引，分库分表   调整数据库参数，调整Innodb基础优化参数，

一些mysql优化方法：
能用between和连接替代in的尽量不用in、
少用select *、
只需要一条数据时limit 1、
排序字段没有索引尽量别排序、
限制条件其他字段没有索引尽量少用or（可以用union all代替，也尽量少用union<-要先进行合并）、
in适合外表大内表小，exists则相反，
尽量别用not in、
使用合理分页方式、
分段查询、
避免使用where对null进行判断、
避免使用where时触发数据类型隐式转换、
避免使用%前缀查询，若要用可添加全局索引、
避免在where中对表达式进行操作、
对于联合索引遵守最左前缀法则、
范围查询会导致联合索引后面的索引失效、
尽量用inner join自动选择小表，
on的限制选择有索引的字段，

mysql索引优化：
主键索引、唯一索引UNIQUE（列值必须唯一，允许有空值，也可以创建唯一组合索引）、普通索引、组合索引 INDEX、全文索引FULLTEXT，唯一索引和普通索引要指定索引名。
索引一经创建不能修改，只能删除重建。DROP INDEX。
适合索引的列是出现在where子句中的列或连接子句中指定的列，给基数（单个列唯一键的数量）大的建立索引，如果字段很长要指定前缀长度，否则索引会占用很多额外空间、更新频繁的字段不适合建立索引
索引多了浪费空间（B+Tree的特性）
mysql引擎
锁：表级锁（开销小，加锁快，不会出现死锁，并发低，冲突概率大），页面级锁（会死锁，其余介于之间），行级锁（开销大，加锁慢，会出现死锁，粒度小，并发高，冲突概率小）
InnoDB：事务性存储引擎，有行级锁定和外键约束
事务隔离级别：读未提交，读已提交，可重复读，串行化
特性：提供了对数据库事务A(操作要么全做要么不做)C(即使事务是并发的，系统也必须如同串行事务一样执行)I(保证同一时间只有一个事务操作同一数据)D(事务完成后所做更改不会被回滚)的支持，实现了SQL标准四种隔离级别。运行时会在内存中建立缓冲池，用于缓冲数据和索引。但因为未保存表的行数select  count（*） from table需要扫描全表。不支持FULLTEXT索引。锁的粒度小，默认行级锁，写操作不会锁定全表，对并发支持度更高，仅当不能确定扫描范围时适用表级锁。
适用：经常更新的表，支持事务，可从灾难中恢复，外键约束，支持自增
MyISAM：mysql默认引擎，不支持事务，不支持外键，不支持行级锁，
适用：查询很快，需要对整张表整天加锁，select  count（*） from table不用扫描整张表，读取值即可，不能恢复数据

两者索引：都是用的B+树，非叶子节点存值和指针，一个节点为一页（16k），每次IO操作查询一页，InnoDB叶子节点直接存数据，树高3层就能满足千万级数据存储，MyISAM叶子节点存的是数据地址，InnoDB主键索引查询效率很高
5、线程的各个状态，启动流程，线程池
状态：初始（未调用start()），运行（包含就绪状态，调用start()后），阻塞（进入同步队列争抢，一个对象对应一个同步队列），等待（等待通知或中断，在等待队列中），超时等待（指定时间后自行返回，不会一直等），终止（run运行完了或main运行完了，不能复生）
Thread.sleep(long mills)-不释放锁，由运行状态变为超时等待状态，给其他线程机会，舒醒后进入就绪状态
Thread.yield()-不释放锁，由运行状态变为就绪状态，便于相同优先级线程再次竞争CPU
t.join()/t.join(long mills)-不释放锁，由运行状态进入等待/超时等待状态，t执行完后/时间到后进入就绪状态
obj.wait()/obj.wait(long timeout)-释放锁，由运行状态进入等待状态，处在等待队列，直到notify()/notifyAll()/timeout时间到唤醒自己进入就绪状态，处在同步队列
obj.notify()/obj.notifyAll()-唤醒所有等待队列的线程进入同步队列

线程池：并发线程数量很多，频繁的创建销毁降低系统效率，
Java线程池类ThreadPoolExecutor继承抽象类AbstractExecutorService（实现ExecutorService接口，继承Executor，定义execute(Runnable command)方法，执行传进去的任务），提供了四个构造器，
参数含义
 corePoolSize-核心池（默认没有任何线程，有任务到来才创建，除非调用prestart（All）CoreThreads，达到上限后将后续任务放入缓存队列）大小、maximumPoolSize-线程池最大线程数、keepAliveTime-空闲时线程存活时间（默认超过核心池大小才会发生终止，若调用allowCoreThreadTimeOut(boolean)所有线程都会终止）、unit-keepAliveTime的单位（TimeUnit.DAYS/HOURS/MINUTES/SECONDS/MILLISECONDS/...）、workQueue-阻塞队列（ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue）、threadFactory-线程工厂、handler-拒绝处理任务时的策略	
重要方法
execute()-提交一个任务
submit()-提交一个任务并通过Future获取并返回任务执行结果，也是调用execute()
shutdown()-关闭线程
shutdownNow()-关闭线程
原理
volatile变量runState表示当前线程池的状态（RUNNING,SHUTDOWN,STOP,TERMINATED）

6、http请求协议中host首部行对服务器的作用，GET请求存在什么问题
决定要访问哪个虚拟主机。GET请求参数不安全

7、linux如何获知某个进程的目录
pwdx pid

8、linux的fd
文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。
使用ulimit -n命令可以查看可使用最大文件描述符数量
文件描述符与文件是多对一的关系，每个进程有一张自己的文件描述符表，系统有一张文件描述符表（文件打开表）进程文件描述符表->文件打开表->文件

IO多路复用：select、poll、epoll（一个TCP连接对应一个socket句柄，即对应一个文件句柄）与高并发的关系
select轮询，需要复制大量句柄数据结构，用户/内核句柄拷贝，内核需要遍历整个数组才能发现哪些句柄发生了事件，未发生事件会反复通知，遍历完后又复制到用户态，而且返回的是含有整个句柄的数组，应用程序需要再次遍历，句柄数量有限制，越多开销越大
poll使用链表保存文件描述符，没有了数量限制，但拷贝轮询水平触发的缺点还在
epoll使用红黑树+双端链表的结构，操作epoll_create(int size)-创建一个文件inode节点，占用一个fd值、epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)-操作（将连接加入红黑树rbr或删除，针对某个create返回的inode的文件描述符关联的所有句柄）、epoll_wait()-检查事件，判断rdlist是否为空即可，只用复制链表中的事件。（事件与网卡驱动程序建立回调关系，发生事件时会调用ep_poll_callback()回调方法将事件添加到rdlist双端链表中）

9、linux抓包、unix网络编程
tcpdump（默认第一个网络接口上所有数据包）
-i 接口
host 主机名

10、如何处理uri参数中的特殊字符
使用%接ASCLL码的方式，eg：+->%2B

11、账号密码安全性处理
CA使用私钥对Hash后的非对称加密公钥及服务器信息进行加密，将数字证书颁发给服务器（使用HTTPS），服务器将证书和原始信息传给客户端，客户端拥有CA公钥，对数字证书进行解密，对原始信息进行Hash比对摘要信息，一致则保存公钥，然后用公钥将对称加密密钥进行加密，服务器用自己的非对称加密私钥解密获取对称加密密钥。
对用户传过来的密码在前端进行加盐md5单向散列，防止直观的看到密码，传到服务器后再用服务器随机生成的盐（timestamp）进行md5单向散列存入数据库
登录时验证二次散列后和数据库存的密码是否相同
登陆后记录token，用户拿到的不是真正的token，而是没有统一前缀的token

12、C++纯虚函数定义，虚函数表，函数指针和指针函数、多态实现原理


13、TCP四次挥手过程中客户端服务器端的各个状态，TCP报文段最大传输长度和是怎么算出来的，如何避免IP分片
IP分片会导致大量数据重传，代价很大，所以要限制应用层报文长度，使封装后的传输层报文段层层封装后长度不要超过数据链路层上限

14、equals是怎么判断两个处于不同内存的对象相等的
继承Object类的类能够重写equals方法，用来判断两个对象的一致，默认判断所引用的对象是否是同一对象

15、ArrayList和LinkedList区别，都实现了List接口
一个是对数组的包装，当数组满后它会再分配更大的新的数组，一个是用链表实现的，所以未实现RandomAccess接口

16、序列化作用(将对象转换为字节序列，能够永久保存到硬盘上，也便于在网络上传输字节序列)
实现Serializable接口的对象能够被反序列化创建一个单独的对象

17、REST 表象层状态转移 是一种设计风格，从资源的角度观察整个网络
每个uri代表一种资源
表象层是指传递的资源的某种表现形式：content-type  eg：text/xml/json/binary/form-data（表单中有文件传输）/x-www-form-urlencoded（表单）
状态转移通过HTTP的标准请求方法操作资源，
GET请求参数展现地址栏不安全

18、Java对象的创建过程：类的初始化和实例化
加载类型->初始化->实例化->使用
方法：
new 能使用任何构造方法，由执行类实例创建表达式而引起的对象创建
下面三种都是通过转变为invokevirtual指令直接创建对象：
反射机制 Class.newInstance-使用无参构造方法->Constructor.newInstance-能使用无参/有参/私有构造方法 
Clone 实现Cloneable接口实现clone方法，不使用构造方法
反序列化 不使用构造方法，ObjectOutputStream、ObjectInputStream

虚拟机流程：创建时为对象分配内存保存自身的和继承的实例变量，赋默认值零按程序员意志进行初始化-按序实例变量初始化、实例代码块（{}）初始化、构造函数初始化	实例化类之前会实例化其父类，在构造函数第一条调用（递归过程）
加载-验证-准备-解析-初始化	